---
title: 算法学习笔记
date: 2021-10-10 15:08:00 +08:00
tags: 算法
mathjax: true
---

学习算法的过程中看题解是很重要的一环，但往往题解只提供一种解法，角度难免片面。因此这里主要以题目为中心，整理我看到的各种解法以及一些个人感想。

## P1115 最大子段和

这题贪心应该是最直接的方法，也同时可以用前缀和的思想做。

题目要求的是选连续的一段，而且不限制长度，如果我们又枚举起点又枚举长度就会 $O(n^2)$ .

起点不确定的情况不好控制，我们可以把子段和转化成：第 $1$ 到 $x$ 个数之和减去第 $1$ 到 $y$ 个数之和，其中 $x > y$ . 对于每一个 $x$ ，问题就转换成了求最小前缀和。时间复杂度 $O(n)$.

贪心就更直接了。设当前以第 $i$ 个数结尾的子段最大和为 $dp[i]$ ，我们可以看出若是 $dp[i - 1] + a[i] < 0$，我们就还不如不选第 $i$ 个数，直接 $dp[i] = 0$ 即可。其他情况下就必然是 $dp[i] = dp[i - 1] + a[i]$. 最后找出最大的 $dp[i]$ 就可以了。由于 $dp[i]$ 可以直接由一个变量存储，空间复杂度 $O(1)$. 时间复杂度 $O(n)$.

## CF1573B Swaps

这题看起来很复杂，其实就一个关键点：$a$ 都为奇数而 $b$ 都为偶数，因此这两个数组从第一个数开始就不一样。想让 $a$ 字典序小于 $b$ 的话，就需要且仅需要 $a_1<b_1$. 所以只要找到一对 $a_i$ 和 $b_j$ 满足 $a_i<b_j$ 并一个一个把这两个数分别移到最前面就好了。此时问题就转化为找最小的 $i+j-2$. （若下标从 $0$ 开始则为最小的 $i+j$）

假设我们一定要选某个 $b$ 中的偶数 $b_j$，此时我们只需要找满足 $a_i<b_j$ 的下标最小的 $a_i$ 即为最优解。因此我们可以这样做：开一个数组 $p$ 记录某个数 $n$ 在数组 $a/b$ 中的位置 $p_n$. 从大到小遍历所有的数，然后用一个变量 $l$ 记录当前遍历到的 $a$ 中最小的下标，若当前数 $n$ 为奇数则 $l=min(l, p_n)$，若当前为偶数则更新答案为 $min(answer, p_n + l)$. （注意这里认为下标从 $0$ 开始）

## ABC223B String Shifting

不知道是不是受到之前做的一道很类似的题的影响，这题想了很久很久。

首先分析问题：题目中的平移可等价为把字符串的前$n$个字符移到最后或者把字符串的后$n$个字符移到最前。那么我们首先会发现把前$n$个字符移动到最后等价于把后$length-n$个字符移动到最前，我们只用关心移动到最前（或最后）的情况。由于每次只能操作最后的$n$个字符，无论操作多少次都可等价于操作一次。那么问题转化为：

> 给定非空字符串$S$，选择$S$的后$n$个字符移动到首端。分别求移动后使得$S$字典序最大和最小的$n$。

剩下的就很简单了：鉴于$n\leq1000$，我们直接枚举所有可能的$n$，把最大的和最小的找出来就好了。（然而因为没注意到这个题允许$O(n^2)$时间复杂度我卡了1hr多）

## 2019年广东工业大学新生赛 F 失踪的玫瑰

参考：[【题解】2019年广东工业大学腾讯杯新生程序设计竞赛](https://www.nowcoder.com/discuss/352755)

题面可以等价转换为：有$n$个山洞，初始状态下每个山洞里都有一只狐狸，每天晚上每只没抓住的狐狸都会分身去两边的洞，每天白天都有一个猎人去查看一个山洞，求抓住全部狐狸的方案数。以下用x代表一定没有狐狸的洞口，用o代表有狐狸的洞口。对于$n=5$的情况，我们从右往左依次检查试试：

| 检查洞口 | 白天抓捕完后 | 过了一晚上后 |
| -------- | ------------ | ------------ |
| 5        | oooo**x**    | ooooo        |
| 4        | ooo**x**o    | oooox        |
| 3        | oo**x**ox    | oooxo        |
| 2        | o**x**oxo    | xoxox        |

可以看出最后一次抓捕的下一个白天，所有奇数洞都没有狐狸。

下面有一个重要的结论：

每天检查之后，被检查的洞的右边**不会存在开局位于奇数洞**的狐狸。

为什么呢？

因为开局在奇数洞的狐狸，在奇数次抓捕时必定在奇数洞里，在偶数次抓捕时必定在偶数洞里。开局在偶数洞的狐狸正好相反。而从奇数洞走到旁边的奇数洞需要2个晚上，被检查的洞的左边的狐狸若是想走到右边，必定会在移动时遇到抓捕。

这里还应注意到的是，我们第一天检查5号洞口后，4号洞口的狐狸当晚就会分身去5号洞口，也就是说检查两边的洞口是**无效的**。因此3天即可抓捕完奇数洞狐狸。

如果要抓开局位于偶数洞的狐狸呢？

| 检查洞口 | 白天抓捕完后 | 过了一晚上后 |
| -------- | ------------ | ------------ |
| 4        | ooo**x**o    | oooox        |
| 3        | oo**x**ox    | oooxo        |
| 2        | o**x**oxo    | xoxox        |

3天即可抓捕完。

然后呢，抓奇数洞狐狸？诶奇数洞怎么已经没有狐狸了？这是因为我们花了奇数天抓捕，开局偶数洞的狐狸一晚上后都在奇数洞。那么我们能不能把这个当作开局状态，再来一次偶数洞狐狸抓捕？

当然可以！最后答案是$\{4,3,2,4,3,2\}$，但是这不是字典序最小的方案。因为选择从左到右给洞穴标号还是从右到左给洞穴标号是不重要的，所以答案为$\{2,3,4,2,3,4\}$.

再经过一些推导，洞穴个数$n$为奇数时都为这种情况，即$\{2,3,4,\cdots ,n-1,2,3,4,\cdots ,n-1\}$.

$n$为偶数时，比如$n=4$时，因为$n-1=3$为奇数，我们就先抓开局奇数洞狐狸：

| 检查洞口 | 白天抓捕完后   | 过了一晚上后 |
| -------- | -------------- | ------------ |
| 3        | oo**x**o       | ooox         |
| 2        | o**x**ox       | xoxo         |
| 3        | xo**x**o（？） | oxox         |
| 2        | o**x**ox（？） | xoxo         |

诶诶诶等一下！这最后两次都抓了个空气啊！

这是因为$n$为偶数时抓奇数洞狐狸所需天数不是奇数天而是偶数天了。开局偶数洞的狐狸一晚上后都在偶数洞。我们要抓偶数洞狐狸，但是不能检查两边的洞口（也就是第1个洞口不能是$n$），所以我们调换方向，从2号洞口开始。

| 检查洞口 | 白天抓捕完后 | 过了一晚上后 |
| -------- | ------------ | ------------ |
| 2        | o**x**oo     | xooo         |
| 3        | xo**x**o     | oxox         |

成功！最后结果是$\{3,2,2,3\}$，调换一下编号方向就是$\{2,3,3,2\}$. 所以$n$为偶数时答案为$\{2,3,\cdots n-1,n-1,n-2,\cdots ,1\}$.

## CF1584B Coloring Rectangles

刚看到这题的时候没什么想法，就乱试。试了半天发现似乎$1\times 3$是最优的切法。然后就开始纠结在特判两条边都不能被$3$整除的情况上。现在回想起来，自己的思维还是太窄了。

然后就想了个DP做法。对于$1\times n$的长方形而言，只需要贪心尽可能多地切成$1\times 3$即可。模拟一下就会发现答案是$\lceil \frac{n}{3} \rceil$​. 于是就可以用DP做了：

```c++
for (int i = 1; i < MAXNM; i++) {
    for (int j = 1; j < MAXNM; j++) {
        dp[i][j] = min(dp[i - 1][j] + ((j + 3 - 1) / 3), dp[i][j - 1] + ((i + 3 - 1) / 3));
    }
}
```

然而看数据范围$1 \leq n, m \leq 3 \cdot 10^4$，被卡了。所以下面是官方题解：

首先找上色后矩形的性质：若一个矩形按照题目要求上色，则相邻的行/列的上色图案正好相反，相邻两行的上色和未上色方块数相同。若长和宽都为偶数，则每两行和列的上色图案将会完全相同。若一个为偶数一个为奇数，则每两行或列的上色图案将会完全相同，这两行内部互相上色方块数将相差1. 这两种情况下上色和未上色方块数都相同，即上色方块占所有方块的$\frac{1}{2}$。但若长和宽都为奇数，上色和未上色方块数将会相差1. 令方块总数（面积）为$S$, 则上色方块数为$\frac{S - 1}{2}$, 占所有方块的$\frac{S - 1}{2 \cdot S}$.

我们的期望是上色方块的比例尽可能小。根据题目条件$S\geq 2$，因此当$S=3$时$\frac{S - 1}{2 \cdot S}=\frac{1}{3}$为可能的最小值。因此，这就是对答案的最小估计：$n \cdot m \cdot \frac{1}{3} \leq answer$.

现在，如果我们构造出一个要求必须给$cnt$个方块上色的剪切方案，且$\frac{n \cdot m}{3} \leq cnt < \frac{n \cdot m}{3} + 1$，那么答案就是$cnt$. （也即这个剪切方案就是最优方案）因为$cnt$是满足我们估计的最小的整数。

如果一条边能被3整除，那么很明显你可以把它全部切成$1\times 3$的矩形然后得到最优解。

如果这两条边被3除后余1和1，或者余2和2，那么你可以把它切成一些$1\times 3$的矩形，加上一个$1\times 4$或$2\times 2$的矩形。多出来的这个矩形里要给2个方块上色，显然满足要求。

如果这两条边被3除后余1和2，那么你可以把它切成一些$1\times 3$的矩形，加上一个$1\times 2$的矩形。多出来的这个矩形里要给1个方块上色，显然满足要求。

由答案必须是整数，可得答案为$\lceil \frac{n \cdot m}{3} \rceil$.

## P5824 十二重计数法

自己做的，好像有些错误。先记着吧。

1. 问题可转化成有$n$个有编号的格子，每个格子可填入$1\sim m$的任意整数。题目正好对应为$m$进制下$1\sim n$位数的个数，也即$n^m$.（**可重复排列**）
2. 先从$[1,n]$中选出$m$个数，然后全排列。即$C_n^m\cdot A_m^m$.
3. 可拆分成：先从$[1,n]$中选出$m$个数，使它们装到$m$个盒子中，每个盒子至多装一个球，也即问题2；剩下的$n-m$个球可以任意装到盒子中，也即问题1. 答案$C_n^m\cdot A_m^m\cdot (n-m)^m$.
4. 盒子全部相同，意味着哪些球在一个盒子里重要，但是具体在哪一个盒子不重要。问题1除以盒子的排列数$A_m^m$即可。但是我们也可以用隔板法：$1,2,\cdots ,n$编号的小球打乱顺序后之间放上$m-1$个隔板。即为$A_n^n\cdot C_{n+1}^{m-1}$.
5. **不可重复组合**：$C_n^m$.
6. 先从$[1,n]$中选出$m$个数直接装到盒子中，剩下的$n-m$个球任意装。$C_n^m\cdot A_{n-m}^{n-m}\cdot C_{n-m+1}^{m-1}$.
7. 球全部相同，意味着盒子里有多少球重要，但是具体是哪些球不重要。可用隔板法：$n$个小球中间放上$m-1$个隔板，即$C_{n+1}^{m-1}$.
8. 盒子只有两种状态：装了一个球/没装球。选出装了球的盒子即为$C_m^n$.
9. 每个盒子都装一个球后剩下的球有$n-m$个，回到问题7，即$C_{n-m+1}^{m-1}$.
10. 从这开始就有点难了，先模拟一下：设装球最少的盒子装了$x$个球，那么装球第二少的盒子可以装$[x,m]$个，

## 2021广东工业大学新生赛初赛题解与反思

初赛结果不理想，只出了5个题。

其实回想起来有些题赛时本来能做出来的，但是因为各种原因没做好，在此纪录。也一并为以后的学习指明方向。

### [A 简单的求零点问题](https://gdutcode.cn/contest/15/problem/A)

很显然，用二分找零点。但是我一看到这题就有点犯难，为什么呢？因为我**连二分都不能熟练地码出来**。

所以今天整理一下二分。（参考[这篇文章](https://segmentfault.com/a/1190000008699980)）

#### 如何快速判断自己的二分程序是否正确

我们知道二分的思想就是每次取一半，想象一下，不管给我们的数组有多长，每次取一半，最终都会被压缩成长度为 1 的数组，然后在这个长度为 1 的数组里判断并返回，所以我们可以直接用长度为 1 的数组来测试程序。

#### 二分查找

给定长度为n的数组（$n\geq 1$）

问题1：找到值为value的元素的下标

```c++
int BinarySearch(int array[], int n, int value) {
    int left = 0;
    int right = n - 1;
    while (left <= right) {
        // 注意防止溢出
        int middle = left + ((right - left) >> 1);
        if (array[middle] > value) {
            right = middle - 1;
        } else if (array[middle] < value) {
            left = middle + 1;
        } else {
            return middle;
        }
    }
    return -1;
}
```

问题2：找到**第一个**值为value的元素的下标

这时候遇到相等也不能直接返回，只能排除掉右侧的所有数。

数组的长度为 1 或 2 时，`middle`为 0. 若`array[0]`为要找的数，则`right`将被赋值为 -1，循环结束，`left`为答案。数组长度为 2 且`array[1]`为要找的数时，`left`将被赋值为 1，回到数组长度为 1 的情况。

因此最后再判断一下`left`是否为要找的数，如果是则返回，否则答案不存在。

```c++
int BinarySearch(int array[], int n, int value) {
    int left = 0;
    int right = n - 1;

    while (left <= right) {
        int middle = left + ((right - left) >> 1);

        if (array[middle] >= value) {
            right = middle - 1;
        } else {
            left = middle + 1;
        }
    }

    if (left < n && array[left] == value) {
        return left;
    }
    return -1;
}
```

问题3：找到**最后一个**值为value的元素的下标

这就是问题2的倒序版本。改动两个地方即可

1. `if (array[middle] >= value)` 中的等号去掉；

2. ```c++
   if (right >= 0 && array[right] == value) {
       return right;
   }
   ```

问题4：找到**第一个大于等于**value的下标

在问题2中，我们的策略是让`left`刚好为第一个大于等于value的数的下标，而让`right`刚好为第一个小于value的数的下标。因此只需要去掉最后判断答案存在的`array[left] == value`条件即可。

问题5：找到**最后一个小于等于**value的下标

与问题4同理，去掉问题3中最后判断答案存在的`array[right] == value`条件。

### [B a+b(easy)](https://gdutcode.cn/contest/15/problem/B)

这题能卡我，题面也要背点锅。赛时的样例1输入为`1 2`输出为`3`. 而我又**对位运算不够熟悉**，在无论如何也找不到对应的x和y时陷入了自我怀疑之中。

题目本身确实很简单。取或运算可以看成不进位，只把每一位单独加起来。取和运算就看成每一位会不会进位（二进制加法只有进位/不进位两种可能）。那么加起来自然就与这两个数本身加起来相等。

### [C 百家姓与年龄](https://gdutcode.cn/contest/15/problem/C)

这道题题面看起来有点混乱……本来不复杂的描述参杂了3个人进来，还有两个人名字就差一个字母。当时愣是来回看了三四遍才明白意思。**下次读题要冷静，快速排除无关信息。**

读完题，把式子列出来一算就很显然了。令$x$为出生年份，$y$为排位。
$$
\begin{aligned}
a&=50(2y+5)+1771-x\\
&=100y+2021-x
\end{aligned}
$$
联想到今年是2021年，$2021-x$为年龄，且年龄小于100岁。年龄即为$a$的最后两位数，排位为余下的数。

~~所以这道题的保质期已经不足两个月了。~~

~~所以居然是年龄小于100而不是百家姓排位小于100。~~

### [D 帮助小鱼](https://gdutcode.cn/contest/15/problem/D)

> 接下来 $n$ 个数，第 $i$ 个数代表第 $i$ 个部长摸了那一条鱼。

又懵逼半天，这到底输入的啥。

最后就是开个桶或者map记录鱼被谁摸，然后顺序输出就好了。

### [E 上楼方式](https://gdutcode.cn/contest/15/problem/E)

整个比赛中做的最错误的决定就是第二个读这道题。

当时自己晚了3分钟开始（定了个开始前20分钟的闹钟，响了以后就坐在电脑前等，然后居然忘记定开场时的闹钟了），然后眼看着其他题都被人AC过了，这道题还没有。再加上有上楼梯这种经典递推板题的存在，我信 心 满 满地准备试一试。

~~这题怎么也有3个莫名其妙的名字。~~

然后就读错题了，3步登上教堂我想当然地以为是踩3阶楼梯。其实是指在楼梯上移动三次，比如1-2-3-4.

第一阶必定是1，最后一阶必定是$n$，所以上楼方案数为$C_{n-2}^2$.

## CF1603A Di-visible Confusion

首先分析操作：决定一个数能否被删除的只有它的序号，因此删除某个数对它左边的数没有影响，而右边的数也不会关心具体是哪个数被删除了。所以，从右往左贪心删除一定是最优的方案。

题目问的是一个序列能不能被全部删除，所以我们就要找反面：从右往左贪心删除时会遇到所有数都无法被删除的局面。再联系刚才说了删除操作对左边的数没影响可知，如果一个序列前面某几项都被$(i+1)$整除，那么这个序列必定无法被全部删除。即若第一项被$2$整除，整个序列必定无法被全部删除。

继续推广，如果第$i$项被$(i+1)!$整除，那么整个序列必定无法被全部删除。由于阶乘的增长速度是很大的，而$a_i\leq 10^9$，所以一旦阶乘超过$10^9$就不用看后面的了。

写出来一交，Wrong Answer.

上面推广的过程是错误的。应该把$(i+1)!$换成$LCM(2,3,\cdots,i+1)$. 把最大公倍数当成乘法这个操作在新生赛初赛中已经搞过一次，现在印象够深刻了。说到底，还是数论相关题目自己做得太少，知识也不牢固。
